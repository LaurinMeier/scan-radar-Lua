--proof of concept radar contact sorter made for the VS code plugin StormworksLifeboatAPI



pi2=math.pi*2
ign=input.getNumber
sin=math.sin
cos=math.cos

vec=function(x,y,z)return{x=x or 0,y=y or 0,z=z or 0}end
function Cross(A,B)return vec(A.y*B.z-A.z*B.y,A.z*B.x-A.x*B.z,A.x*B.y-A.y*B.x)end
function clamp(x,l,h)return math.min(h,math.max(x,l))end
function antiNan(x)return x==x and x or 0 end

function radarToGlobal(dist, az, el, pos, orth)
	local x=sin(az*pi2)*cos(el*pi2)*dist
	local y=cos(az*pi2)*cos(el*pi2)*dist
	local z=sin(el*pi2)*dist
	return vec(orth.r.x*x+orth.f.x*y+orth.u.x*z+pos.x,  orth.r.y*x+orth.f.y*y+orth.u.y*z+pos.y,   orth.r.z*x+orth.f.z*y+orth.u.z*z+pos.z)
end

function screen.drawPixel(x,y)
    screen.drawRectF(math.floor(x+0.5),math.floor(y+0.5),1,1)
end

function pulse(bool,name)
    local res = false
    if not dshw then dshw = {} end
    if bool and not dshw[name] or false then res = true end
    dshw[name] = bool
    return res
end

function math.map(x, min, max, low, high)
    return (x-min)/(max-min)*(high-low)+low
end

function dist(x1,y1,z1,x2,y2,z2)
    return math.sqrt((x1-x2)^2+(y1-y2)^2+(z1-z2)^2)
end

function delta(x, name)
    if not ksnfi then ksnfi = {} end
    local delta = x-(ksnfi[name] or x)
    ksnfi[name]=x
    return delta
end


function EMA(x,a,name)
    if not EMAtbl then EMAtbl={} end
    local y = a*x+(1-a)*(EMAtbl[name] or x)
    EMAtbl[name] = y
    return y
end

function EMAext(x,a,b,name)
    if not EMAtblExtr then EMAtblExtr={} end
    local EMAval = EMA(x, a, name)
    local EMAext = EMAval + EMA(EMAval-(EMAtblExtr[name] or EMAval), b, name.."2")*(1/a)
    EMAtblExtr[name] = EMAval
    return EMAext
end

function reset(i)
    EMAtbl["knownX"..i]=nil
    EMAtbl["knownX"..i.."2"]=nil
    EMAtblExtr["knownX"..i]=nil

    EMAtbl["knownY"..i]=nil
    EMAtbl["knownY"..i.."2"]=nil
    EMAtblExtr["knownY"..i]=nil

    EMAtbl["knownZ"..i]=nil
    EMAtbl["knownZ"..i.."2"]=nil
    EMAtblExtr["knownZ"..i]=nil

    EMAtbl["velX"..i]=nil
    EMAtbl["velY"..i]=nil
    EMAtbl["velZ"..i]=nil

    ksnfi["velX"..i]=nil
    ksnfi["velY"..i]=nil
    ksnfi["velZ"..i]=nil
end


posGain = 0.001
velGain = 0.001
extrapolationGain = 0.01
distThreshold = 300
maxLifetime = 900
knownTargets = {}
filteredKnownTargets = {}
filteredVel = {}

function sortContacts(contact)
    contact.z=contact.z or 0
    local nearestTargets = {}
    for i,v in pairs(knownTargets)do
        v.id = i
        table.insert(nearestTargets, v)
    end
    table.sort(nearestTargets, function(a,b)return math.sqrt((a.x-contact.x)^2+(a.y-contact.y)^2+(a.z-contact.z)^2)<math.sqrt((b.x-contact.x)^2+(b.y-contact.y)^2+(b.z-contact.z)^2) end)
    

    if #knownTargets>0 then
        local dist = math.sqrt((nearestTargets[1].x-contact.x)^2+(nearestTargets[1].y-contact.y)^2+(nearestTargets[1].z-contact.z)^2)
        if dist < distThreshold then --update when within x distance
            local lastTime = knownTargets[nearestTargets[1].id].time --save lifeTime of last update
            knownTargets[nearestTargets[1].id] = {x=contact.x,y=contact.y,z=contact.z,time=maxLifetime,lastTime=lastTime}
        end
        if dist > distThreshold*2 then --add new when outside of x*2 distance for noise reasons
            table.insert(knownTargets, {x=contact.x,y=contact.y,z=contact.z,time=maxLifetime})
        end
    else
        table.insert(knownTargets, {x=contact.x,y=contact.y,z=contact.z,time=maxLifetime}) --add new when no knownTarget is present
    end
end


function updateTimes()
    for i,target in pairs(knownTargets) do
        if target.time <=0 then
            knownTargets[i] = nil --remove old targets
            filteredKnownTargets[i] = nil
            reset(i)
        else
            if knownTargets[i].time ~= maxLifetime then --when not updated:
                knownTargets[i].x = knownTargets[i].x + filteredVel[i].x --interpolate with filtered velocity
                knownTargets[i].y = knownTargets[i].y + filteredVel[i].y
                knownTargets[i].z = knownTargets[i].z + filteredVel[i].z
                filteredKnownTargets[i] = {
                    x = EMAext(target.x, posGain, velGain, "knownX"..i), --update the EMA filter
                    y = EMAext(target.y, posGain, velGain, "knownY"..i),
                    z = EMAext(target.z, posGain, velGain, "knownZ"..i),
                    time = target.time
                }
            else --when updated:
                filteredKnownTargets[i] = { --update the EMA filter
                    x = EMAext(target.x, posGain, velGain, "knownX"..i),
                    y = EMAext(target.y, posGain, velGain, "knownY"..i),
                    z = EMAext(target.z, posGain, velGain, "knownZ"..i),
                    time = target.time
                }

                --filter the velocity
                debug = (maxLifetime-(target.lastTime or maxLifetime-1))
                filteredVel[i] = {
                    x=EMA(delta(target.x, "velX"..i)/math.max(maxLifetime-(target.lastTime or maxLifetime-1),1),extrapolationGain,"velX"..i),
                    y=EMA(delta(target.y, "velY"..i)/math.max(maxLifetime-(target.lastTime or maxLifetime-1),1),extrapolationGain,"velY"..i),
                    z=EMA(delta(target.z, "velZ"..i)/math.max(maxLifetime-(target.lastTime or maxLifetime-1),1),extrapolationGain,"velZ"..i)
                }
            end

            knownTargets[i].time = target.time - 1 --update times
            filteredKnownTargets[i].time = target.time
        end
    end
end



contacts={}
function onTick()
    pos = vec(ign(1),ign(3),ign(2))
	rx,ry,rz=ign(4),ign(5),ign(6)
	cx,cy,cz=cos(rx),cos(ry),cos(rz)
	sx,sy,sz=sin(rx),sin(ry),sin(rz)
	right = vec(cy*cz, -sy, cy*sz)
	fwd = vec(sx*sz + cx*sy*cz, cx*cy, -sx*cz + cx*sy*sz)
	up = Cross(right,fwd)
	orth = {r=right,f=fwd,u=up}
	
    --for i=1,5 do
	    --sortContacts(radarToGlobal(ign((i-1)*3+1+6),ign((i-1)*3+2+6),ign((i-1)*3+3+6),pos,orth))
    --end
    --updateTimes()

    for i=1,5 do
        if ign((i-1)*3+1+6) > 100 then
            sortContacts(radarToGlobal(ign((i-1)*3+1+6),ign((i-1)*3+2+6),ign((i-1)*3+3+6),pos,orth))
        end
    end

    updateTimes()

    if filteredKnownTargets[1] then
        output.setNumber(1,filteredKnownTargets[1].x)
        output.setNumber(2,filteredKnownTargets[1].y)
        output.setNumber(3,filteredKnownTargets[1].z)
    end
end

zoom = 5
function onDraw()
    w=screen.getWidth()
	h=screen.getHeight()
	screen.drawMap(pos.x,pos.y,zoom)
    screen.setColor(255,0,0)
	for i,v in pairs(knownTargets) do
        pixelX, pixelY = map.mapToScreen(pos.x, pos.y, zoom, w, h, v.x, v.y)
	    screen.drawRectF(pixelX,pixelY,1,1)
    end

    if filteredKnownTargets[1] then
        screen.drawText(1,1,math.floor(filteredKnownTargets[1].x))
        screen.drawText(1,10,math.floor(filteredKnownTargets[1].y))
    else
        screen.drawText(1,1,"nuh uh")
    end

    if filteredVel[1] then
        screen.drawText(50,1,math.floor(filteredVel[1].x*100)/100)
        screen.drawText(50,10,math.floor(filteredVel[1].y*100)/100)
    else
        screen.drawText(50,1,"nuh uh")
    end

    screen.drawText(1,30,debug)
end
