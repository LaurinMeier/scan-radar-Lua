--proof of concept radar contact sorter made for the VS code plugin StormworksLifeboatAPI



pi2=math.pi*2
ign=input.getNumber
sin=math.sin
cos=math.cos

vec=function(x,y,z)return{x=x or 0,y=y or 0,z=z or 0}end
function Cross(A,B)return vec(A.y*B.z-A.z*B.y,A.z*B.x-A.x*B.z,A.x*B.y-A.y*B.x)end
function clamp(x,l,h)return math.min(h,math.max(x,l))end
function antiNan(x)return x==x and x or 0 end

function radarToGlobal(dist, az, el, pos, orth)
	local x=sin(az*pi2)*cos(el*pi2)*dist
	local y=cos(az*pi2)*cos(el*pi2)*dist
	local z=sin(el*pi2)*dist
	return vec(orth.r.x*x+orth.f.x*y+orth.u.x*z+pos.x,  orth.r.y*x+orth.f.y*y+orth.u.y*z+pos.y,   orth.r.z*x+orth.f.z*y+orth.u.z*z+pos.z)
end

function screen.drawPixel(x,y)
    screen.drawRectF(math.floor(x+0.5),math.floor(y+0.5),1,1)
end

function pulse(bool,name)
    local res = false
    if not dshw then dshw = {} end
    if bool and not dshw[name] or false then res = true end
    dshw[name] = bool
    return res
end

function math.map(x, min, max, low, high)
    return (x-min)/(max-min)*(high-low)+low
end

function distVec(A,B)
    return math.sqrt((A.x-B.x)^2+(A.y-B.y)^2+(A.z-B.z)^2)
end

function len(A) return distVec(vec(),A) end

function delta(x, name)
    if not ksnfi then ksnfi = {} end
    local delta = x-(ksnfi[name] or x)
    ksnfi[name]=x
    return delta
end


function EMA(x,a,name)
    if not EMAtbl then EMAtbl={} end
    local y = a*x+(1-a)*(EMAtbl[name] or x)
    EMAtbl[name] = y
    return y
end

function EMAext(x,a,b,name)
    if not EMAtblExtr then EMAtblExtr={} end
    local EMAval = EMA(x, a, name)
    local EMAext = EMAval + EMA(EMAval-(EMAtblExtr[name] or EMAval), b, name.."2")*(1/a)
    EMAtblExtr[name] = EMAval
    return EMAext
end

function reset(i)
    EMAtbl["knownX"..i]=nil
    EMAtbl["knownX"..i.."2"]=nil
    EMAtblExtr["knownX"..i]=nil

    EMAtbl["knownY"..i]=nil
    EMAtbl["knownY"..i.."2"]=nil
    EMAtblExtr["knownY"..i]=nil

    EMAtbl["knownZ"..i]=nil
    EMAtbl["knownZ"..i.."2"]=nil
    EMAtblExtr["knownZ"..i]=nil

    EMAtbl["velX"..i]=nil
    EMAtbl["velY"..i]=nil
    EMAtbl["velZ"..i]=nil

    ksnfi["velX"..i]=nil
    ksnfi["velY"..i]=nil
    ksnfi["velZ"..i]=nil
end


posGain = property.getNumber("posGain")
velGain = property.getNumber("velGain")
extrapolationGain = property.getNumber("extrapolationGain")
distThreshold = 500
maxLifetime = 900
knownTargets = {}
filteredKnownTargets = {}
filteredVel = {}
averageVel = {}
rawKnownTargets = {}

function sortContacts(contact)
    contact.z=contact.z or 0
    local nearestTargets = {}
    for i,v in pairs(knownTargets)do
        v.id = i
        table.insert(nearestTargets, v)
    end
    table.sort(nearestTargets, function(a,b)return distVec(a,contact)<distVec(b,contact) end)
    

    if #knownTargets>0 then
        local dist = distVec(nearestTargets[1],contact)
        local distPos = distVec(pos, contact)
        if dist < distThreshold*math.max(distPos/5000,1) then --update when within x distance
            local lastTime = knownTargets[nearestTargets[1].id].time --save lifeTime of last update
            knownTargets[nearestTargets[1].id] = {x=contact.x,y=contact.y,z=contact.z,time=maxLifetime,lastTime=lastTime}
            rawKnownTargets[nearestTargets[1].id] = {x=contact.x,y=contact.y,z=contact.z}
        end
        if dist > distThreshold*2*math.max(distPos/5000,1) then --add new when outside of x*2 distance for noise reasons
            local ind = #knownTargets+1
            table.insert(knownTargets, {x=contact.x,y=contact.y,z=contact.z,time=maxLifetime})
            rawKnownTargets[ind] = {x=contact.x,y=contact.y,z=contact.z}
        end
    else
        local ind = #knownTargets+1
        table.insert(knownTargets, {x=contact.x,y=contact.y,z=contact.z,time=maxLifetime}) --add new when no knownTarget is present
        rawKnownTargets[ind] = {x=contact.x,y=contact.y,z=contact.z}
    end
end


function updateTimes()
    for i,target in pairs(knownTargets) do
        if target.time <=0 then
            knownTargets[i] = nil --remove old targets
            filteredKnownTargets[i] = nil
            filteredVel[i] = nil
            reset(i)
        else
            local dist = distVec(pos, target)
            local distFactor = dist/5000
            if knownTargets[i].time ~= maxLifetime then --when not updated:
                knownTargets[i].x = knownTargets[i].x + filteredVel[i].x --interpolate with filtered velocity
                knownTargets[i].y = knownTargets[i].y + filteredVel[i].y
                knownTargets[i].z = knownTargets[i].z + filteredVel[i].z
                filteredKnownTargets[i] = {
                    x = EMAext(target.x, posGain/distFactor, velGain/distFactor, "knownX"..i), --update the EMA filter
                    y = EMAext(target.y, posGain/distFactor, velGain/distFactor, "knownY"..i),
                    z = EMAext(target.z, posGain/distFactor, velGain/distFactor, "knownZ"..i),
                    time = target.time
                }
            else --when updated:
                filteredKnownTargets[i] = { --update the EMA filter
                    x = EMAext(target.x, posGain/distFactor, velGain/distFactor, "knownX"..i),
                    y = EMAext(target.y, posGain/distFactor, velGain/distFactor, "knownY"..i),
                    z = EMAext(target.z, posGain/distFactor, velGain/distFactor, "knownZ"..i),
                    time = target.time
                }

                --filter the velocity
                debug = (maxLifetime-(target.lastTime or maxLifetime-1))
                filteredVel[i] = {
                    x=EMA(delta(rawKnownTargets[i].x, "velX"..i)/math.max(maxLifetime-(target.lastTime or maxLifetime-1),1),extrapolationGain/distFactor,"velX"..i),
                    y=EMA(delta(rawKnownTargets[i].y, "velY"..i)/math.max(maxLifetime-(target.lastTime or maxLifetime-1),1),extrapolationGain/distFactor,"velY"..i),
                    z=EMA(delta(rawKnownTargets[i].z, "velZ"..i)/math.max(maxLifetime-(target.lastTime or maxLifetime-1),1),extrapolationGain/distFactor,"velZ"..i)
                }
                averageVel[i] = {
                    x=EMA(filteredVel[i].x, 0.1/distFactor, "velAvX"..i),
                    y=EMA(filteredVel[i].y, 0.1/distFactor, "velAvY"..i),
                    z=EMA(filteredVel[i].z, 0.1/distFactor, "velAvZ"..i)
                }
            end

            knownTargets[i].time = target.time - 1 --update times
            filteredKnownTargets[i].time = target.time
        end
    end
end



contacts={}
function onTick()
    pos = vec(ign(1),ign(3),ign(2))
	rx,ry,rz=ign(4),ign(5),ign(6)
	cx,cy,cz=cos(rx),cos(ry),cos(rz)
	sx,sy,sz=sin(rx),sin(ry),sin(rz)
	right = vec(cy*cz, -sy, cy*sz)
	fwd = vec(sx*sz + cx*sy*cz, cx*cy, -sx*cz + cx*sy*sz)
	up = Cross(right,fwd)
	orth = {r=right,f=fwd,u=up}
	
    --for i=1,5 do
	    --sortContacts(radarToGlobal(ign((i-1)*3+1+6),ign((i-1)*3+2+6),ign((i-1)*3+3+6),pos,orth))
    --end
    --updateTimes()

    for i=1,5 do
        if ign((i-1)*3+1+6) > 100 then
            sortContacts(radarToGlobal(ign((i-1)*3+1+6),ign((i-1)*3+2+6),ign((i-1)*3+3+6),pos,orth))
        end
    end

    updateTimes()

    if filteredKnownTargets[1] then
        output.setNumber(1,filteredKnownTargets[1].x)
        output.setNumber(2,filteredKnownTargets[1].y)
        output.setNumber(3,filteredKnownTargets[1].z)
    end
end

zoom = 45
function onDraw()
    w=screen.getWidth()
	h=screen.getHeight()
	screen.drawMap(pos.x,pos.y,zoom)
    
	for i,v in pairs(filteredKnownTargets) do
        local c = len(averageVel[i]) < (0.065*distVec(v,pos)/1000+0.2) and 0 or 255
        screen.setColor(c,255-c,0)

        pixelX, pixelY = map.mapToScreen(pos.x, pos.y, zoom, w, h, v.x, v.y)
	    screen.drawRectF(pixelX,pixelY,1,1)
        screen.drawText(pixelX+3,pixelY,math.floor(len(averageVel[i])*1000)/1000)
        screen.drawText(pixelX+3,pixelY+6,math.floor((0.065*distVec(v,pos)/1000+0.2)*1000)/1000)
    end

    if knownTargets[1] then
        screen.drawText(1,1,math.floor(knownTargets[1].x))
        screen.drawText(1,10,math.floor(knownTargets[1].y))
    else
        screen.drawText(1,1,"nuh uh")
    end

    --for i,v in pairs(filteredVel) do
    --    screen.drawText(50,1,math.floor(v.x*100)/100)
    --    screen.drawText(50,10,math.floor(v.y*100)/100)
    --    screen.drawText(50,19,math.floor(v.z*100)/100)
    --    break
    --end
    --for i,v in pairs(averageVel) do
    --    screen.drawText(50,41,math.floor(v.x*100)/100)
    --    screen.drawText(50,50,math.floor(v.y*100)/100)
    --    screen.drawText(50,59,math.floor(v.z*100)/100)
    --    break
    --end

    screen.drawText(1,30,debug)
end
